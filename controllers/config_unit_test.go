package controllers

import (
	"strings"
	"testing"

	multipathv1 "github.com/multipath-operator/api/v1"
	securityv1 "github.com/openshift/api/security/v1"
)

func TestGenerateMultipathConfig(t *testing.T) {
	reconciler := &MultipathReconciler{}

	t.Run("should generate basic configuration with defaults", func(t *testing.T) {
		multipath := &multipathv1.Multipath{
			Spec: multipathv1.MultipathSpec{
				Config: multipathv1.MultipathConfig{
					Defaults: multipathv1.DefaultsConfig{
						UserFriendlyNames:  "yes",
						FindMultipaths:     "yes",
						PathGroupingPolicy: "failover",
						PathSelector:       "round-robin 0",
						PathChecker:        "tur",
						Failback:           "immediate",
						RRWeight:           "priorities",
						NoPathRetry:        "queue",
					},
				},
			},
		}

		config := reconciler.generateMultipathConfig(multipath)

		if !strings.Contains(config, "# Multipath configuration generated by multipath-operator") {
			t.Error("Expected header comment not found")
		}
		if !strings.Contains(config, "defaults {") {
			t.Error("Expected defaults section not found")
		}
		if !strings.Contains(config, "user_friendly_names yes") {
			t.Error("Expected user_friendly_names setting not found")
		}
		if !strings.Contains(config, "find_multipaths yes") {
			t.Error("Expected find_multipaths setting not found")
		}
		if !strings.Contains(config, "path_grouping_policy failover") {
			t.Error("Expected path_grouping_policy setting not found")
		}
	})

	t.Run("should generate blacklist configuration", func(t *testing.T) {
		multipath := &multipathv1.Multipath{
			Spec: multipathv1.MultipathSpec{
				Config: multipathv1.MultipathConfig{
					Blacklist: []multipathv1.BlacklistEntry{
						{
							Devnode: "^(ram|raw|loop|fd|md|dm-|sr|scd|st|dcssblk)[0-9]",
						},
						{
							WWID: "36001405abcdef1234567890",
						},
					},
				},
			},
		}

		config := reconciler.generateMultipathConfig(multipath)

		if !strings.Contains(config, "blacklist {") {
			t.Error("Expected blacklist section not found")
		}
		if !strings.Contains(config, "devnode ^(ram|raw|loop|fd|md|dm-|sr|scd|st|dcssblk)[0-9]") {
			t.Error("Expected devnode blacklist entry not found")
		}
		if !strings.Contains(config, "wwid 36001405abcdef1234567890") {
			t.Error("Expected wwid blacklist entry not found")
		}
	})

	t.Run("should generate device configuration", func(t *testing.T) {
		multipath := &multipathv1.Multipath{
			Spec: multipathv1.MultipathSpec{
				Config: multipathv1.MultipathConfig{
					Devices: []multipathv1.DeviceEntry{
						{
							Vendor:             "NetApp",
							Product:            "LUN",
							PathGroupingPolicy: "group_by_prio",
							PathSelector:       "round-robin 0",
							PathChecker:        "tur",
							Features:           "1 queue_if_no_path",
							HardwareHandler:    "1 alua",
						},
					},
				},
			},
		}

		config := reconciler.generateMultipathConfig(multipath)

		if !strings.Contains(config, "devices {") {
			t.Error("Expected devices section not found")
		}
		if !strings.Contains(config, "device {") {
			t.Error("Expected device block not found")
		}
		if !strings.Contains(config, "vendor NetApp") {
			t.Error("Expected vendor setting not found")
		}
		if !strings.Contains(config, "product LUN") {
			t.Error("Expected product setting not found")
		}
		if !strings.Contains(config, "path_grouping_policy group_by_prio") {
			t.Error("Expected path_grouping_policy setting not found")
		}
	})

	t.Run("should generate multipath device configuration", func(t *testing.T) {
		multipath := &multipathv1.Multipath{
			Spec: multipathv1.MultipathSpec{
				Config: multipathv1.MultipathConfig{
					Multipaths: []multipathv1.MultipathEntry{
						{
							WWID:               "36001405abcdef1234567890",
							Alias:              "test-multipath-device",
							PathGroupingPolicy: "failover",
							PathSelector:       "round-robin 0",
							Failback:           "immediate",
						},
					},
				},
			},
		}

		config := reconciler.generateMultipathConfig(multipath)

		if !strings.Contains(config, "multipaths {") {
			t.Error("Expected multipaths section not found")
		}
		if !strings.Contains(config, "multipath {") {
			t.Error("Expected multipath block not found")
		}
		if !strings.Contains(config, "wwid 36001405abcdef1234567890") {
			t.Error("Expected wwid setting not found")
		}
		if !strings.Contains(config, "alias test-multipath-device") {
			t.Error("Expected alias setting not found")
		}
	})

	t.Run("should handle empty configuration", func(t *testing.T) {
		multipath := &multipathv1.Multipath{
			Spec: multipathv1.MultipathSpec{
				Config: multipathv1.MultipathConfig{},
			},
		}

		config := reconciler.generateMultipathConfig(multipath)

		if !strings.Contains(config, "# Multipath configuration generated by multipath-operator") {
			t.Error("Expected header comment not found")
		}
		if strings.Contains(config, "defaults {") {
			t.Error("Unexpected defaults section found")
		}
		if strings.Contains(config, "blacklist {") {
			t.Error("Unexpected blacklist section found")
		}
	})
}

func TestGenerateBlacklistConfig(t *testing.T) {
	reconciler := &MultipathReconciler{}

	t.Run("should handle empty blacklist", func(t *testing.T) {
		entries := []multipathv1.BlacklistEntry{}
		config := reconciler.generateBlacklistConfig(entries, "blacklist")
		if config != "" {
			t.Error("Expected empty config for empty blacklist")
		}
	})

	t.Run("should generate devnode entries", func(t *testing.T) {
		entries := []multipathv1.BlacklistEntry{
			{Devnode: "^sda"},
			{Devnode: "^sdb"},
		}
		config := reconciler.generateBlacklistConfig(entries, "blacklist")

		if !strings.Contains(config, "blacklist {") {
			t.Error("Expected blacklist section not found")
		}
		if !strings.Contains(config, "devnode ^sda") {
			t.Error("Expected devnode ^sda not found")
		}
		if !strings.Contains(config, "devnode ^sdb") {
			t.Error("Expected devnode ^sdb not found")
		}
	})

	t.Run("should generate device block entries", func(t *testing.T) {
		entries := []multipathv1.BlacklistEntry{
			{
				Device: multipathv1.DeviceIdentifier{
					Vendor:  "TestVendor",
					Product: "TestProduct",
				},
			},
		}
		config := reconciler.generateBlacklistConfig(entries, "blacklist")

		if !strings.Contains(config, "blacklist {") {
			t.Error("Expected blacklist section not found")
		}
		if !strings.Contains(config, "device {") {
			t.Error("Expected device block not found")
		}
		if !strings.Contains(config, "vendor TestVendor") {
			t.Error("Expected vendor setting not found")
		}
		if !strings.Contains(config, "product TestProduct") {
			t.Error("Expected product setting not found")
		}
	})
}

func TestSCCSpec(t *testing.T) {
	reconciler := &MultipathReconciler{}

	// Create a mock SCC to test the spec setting
	scc := &securityv1.SecurityContextConstraints{}
	reconciler.setSCCSpec(scc)

	if !scc.AllowPrivilegedContainer {
		t.Error("Expected AllowPrivilegedContainer to be true")
	}
	if !scc.AllowHostNetwork {
		t.Error("Expected AllowHostNetwork to be true")
	}
	if !scc.AllowHostPID {
		t.Error("Expected AllowHostPID to be true")
	}
	if !scc.AllowHostDirVolumePlugin {
		t.Error("Expected AllowHostDirVolumePlugin to be true")
	}
	if scc.AllowPrivilegeEscalation == nil || !*scc.AllowPrivilegeEscalation {
		t.Error("Expected AllowPrivilegeEscalation to be true")
	}

	expectedUser := "system:serviceaccount:" + MultipathNamespace + ":multipath-daemon"
	found := false
	for _, user := range scc.Users {
		if user == expectedUser {
			found = true
			break
		}
	}
	if !found {
		t.Errorf("Expected user %s not found in SCC users", expectedUser)
	}
}
